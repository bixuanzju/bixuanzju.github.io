[{"authors":["**Xuan Bi**","Bruno C. d. S. Oliveira","Tom Schrijvers"],"categories":null,"date":1532044800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1532423509,"objectID":"39c7987558132d27f3bba3ab78bb7205","permalink":"https://bixuanzju.github.io/publication/nested-composition/","publishdate":"2018-07-20T00:00:00Z","relpermalink":"/publication/nested-composition/","section":"publication","summary":"Calculi with disjoint intersection types support an introduction form for intersections called the merge operator, while retaining a coherent semantics. Disjoint intersections types have great potential to serve as a foundation for powerful, flexible and yet type-safe and easy to reason OO languages. This paper shows how to significantly increase the expressive power of disjoint intersection types by adding support for nested subtyping and composition, which enables simple forms of family polymorphism to be expressed in the calculus. The extension with nested sub- typing and composition is challenging, for two different reasons. Firstly, the subtyping relation that supports these features is non-trivial, especially when it comes to obtaining an algorithmic version. Secondly, the syntactic method used to prove coherence for previous calculi with disjoint intersection types is too inflexible, making it hard to extend those calculi with new features (such as nested subtyping). We show how to address the first problem by adapting and extending the Barendregt, Coppo and Dezani (BCD) subtyping rules for intersections with records and coercions. A sound and complete algorithmic system is obtained by using an approach inspired by Pierce’s work. To address the second problem we replace the syntactic method to prove coherence, by a semantic proof method based on logical relations. Our work has been fully formalized in Coq, and we have an implementation of our calculus.","tags":null,"title":"The Essence of Nested Composition","type":"publication"},{"authors":["**Xuan Bi**","Bruno C. d. S. Oliveira"],"categories":null,"date":1531958400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1532423509,"objectID":"ede65732a0f67ab68c54c0561fccee5a","permalink":"https://bixuanzju.github.io/publication/typed-first-class-traits/","publishdate":"2018-07-19T00:00:00Z","relpermalink":"/publication/typed-first-class-traits/","section":"publication","summary":"Many dynamically typed languages (including JavaScript, Ruby, Python or Racket) support first-class classes, or related concepts such as first-class traits and/or mixins. In those languages classes are first-class values and, like any other values, they can be passed as an argument, or returned from a function. Furthermore first class classes support dynamic inheritance: i.e. they can inherit from other classes at runtime, enabling programmers to abstract over the inheritance hierarchy. In contrast, type system limitations prevent most statically typed languages from having first-class classes and dynamic inheritance. This paper shows the design of SEDEL: a polymorphic statically typed language with first- class traits, supporting dynamic inheritance as well as conventional OO features such as dynamic dispatching and abstract methods. The type system for SEDEL is based on the recent work on disjoint intersection types and disjoint polymorphism. However, such previous work is aimed at core calculi, and omits important features for practical OO languages, including (dynamic) inheritance, dynamic dispatching and abstract methods. This paper addresses that gap by showing how to model source language constructs for traits that support such missing features. Inspired by Cook’s work on the denotational semantics for inheritance, we show how to design a source language that can be elaborated into Alpuim et al.'s Fi which is a polymorphic calculus with records supporting disjoint polymorphism. We illustrate the applicability of SEDEL with several example uses for first-class traits, and a case study that modularizes programming language interpreters using a highly modular form of visitors.","tags":null,"title":"Typed First-Class Traits","type":"publication"},{"authors":["Ningning Xie","**Xuan Bi**","Bruno C. d. S. Oliveira","Tom Schrijvers"],"categories":null,"date":1526342400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1528679587,"objectID":"eb3a39c86315eb83fc26b3402704899e","permalink":"https://bixuanzju.github.io/publication/consistent/","publishdate":"2018-05-15T00:00:00Z","relpermalink":"/publication/consistent/","section":"publication","summary":"Consistent subtyping is employed in some gradual type systems to validate type conversions. The original definition by Siek and Taha serves as a guideline for designing gradual type systems with subtyping. Polymorphic types à la System F also induce a subtyping relation that relates polymorphic types to their instantiations. However Siek and Taha's definition is not adequate for polymorphic subtyping. The first goal of this paper is to propose a generalization of consistent subtyping that is adequate for polymorphic subtyping, and subsumes the original definition by Siek and Taha. The new definition of consistent subtyping provides novel insights with respect to previous polymorphic gradual type systems, which did not employ consistent subtyping. The second goal of this paper is to present a gradually typed calculus for implicit (higher-rank) polymorphism that uses our new notion of consistent subtyping. We develop both declarative and (bidirectional) algorithmic versions for the type system. The algorithmic version employs techniques developed by Dunfield and Krishnaswami to deal with instantiation. We prove that the new calculus satisfies all static aspects of the refined criteria for gradual typing. We also study an extension of the type system with static and gradual type parameters, in an attempt to support a variant of the dynamic criterion for gradual typing. Armed with a coherence conjecture for the extended calculus, we show that the dynamic gradual guarantee of our source language can be reduced to that of λB, which, at the time of writing, is still an open question. Most of the metatheory of this paper, except some manual proofs for the algorithmic type system and extensions, has been mechanically formalized using the Coq proof assistant.","tags":null,"title":"Consistent Subtyping for All (Draft)","type":"publication"},{"authors":null,"categories":null,"date":1523527303,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1528679497,"objectID":"bb4967c27c967f5be6c4ad2642ec904f","permalink":"https://bixuanzju.github.io/project/gpc/","publishdate":"2018-04-12T18:01:43+08:00","relpermalink":"/project/gpc/","section":"project","summary":"Haskell implementation of Gradually Polymorphic Calculus","tags":[],"title":"GPC","type":"project"},{"authors":null,"categories":null,"date":1523527303,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1523677486,"objectID":"aaeca3680a995624ecb142781512cf07","permalink":"https://bixuanzju.github.io/project/necolus/","publishdate":"2018-04-12T18:01:43+08:00","relpermalink":"/project/necolus/","section":"project","summary":"Coq formalization of a coherent calculus with records and disjoint intersection types that supports nested composition","tags":[],"title":"NeColus","type":"project"},{"authors":null,"categories":null,"date":1523527091,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1523677486,"objectID":"daee3f0fa42b77ebb019f322a60c3005","permalink":"https://bixuanzju.github.io/project/sedel/","publishdate":"2018-04-12T17:58:11+08:00","relpermalink":"/project/sedel/","section":"project","summary":"Haskell implementation of a type system for first-class traits","tags":[],"title":"SEDEL","type":"project"},{"authors":["Ningning Xie","**Xuan Bi**","Bruno C. d. S. Oliveira"],"categories":null,"date":1520726400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1528679497,"objectID":"08e43f2242b14299fe4f9dc24a205a07","permalink":"https://bixuanzju.github.io/publication/consistent-subtyping/","publishdate":"2018-03-11T00:00:00Z","relpermalink":"/publication/consistent-subtyping/","section":"publication","summary":"Consistent subtyping is employed in some gradual type systems to validate type conversions. The original definition by Siek and Taha serves as a guideline for designing many gradual type systems with subtyping. Polymorphic types `a la System F also induce a subtyping relation that relates polymorphic types to their instantiations. However Siek and Taha’s definition is not adequate for polymorphic subtyping. The first goal of this paper is to propose a generalization of consistent subtyping that is adequate for polymorphic subtyping, and subsumes the original definition by Siek and Taha. The new definition of consistent subtyping provides novel insights with respect to previous polymorphic gradual type systems, which did not employ consistent subtyping. The second goal of this paper is to present a gradually typed calculus for implicit (higher-rank) polymorphism that uses our new notion of consistent subtyping. We develop both declarative and (bi-directional) algorithmic versions for the type system. We prove that the new calculus satisfies all static aspects of the refined criteria for gradual typing, which are mechanically formalized using the Coq proof assistant.","tags":null,"title":"Consistent Subtyping for All","type":"publication"},{"authors":null,"categories":null,"date":1491991303,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1528679497,"objectID":"e5ffed35198cf3c0c94758cc7a6e4481","permalink":"https://bixuanzju.github.io/project/category/","publishdate":"2017-04-12T18:01:43+08:00","relpermalink":"/project/category/","section":"project","summary":"Category theory formalized in Agda","tags":[],"title":"category-agda","type":"project"},{"authors":null,"categories":null,"date":1483200000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1533009520,"objectID":"794ba5efc7393cb291e830d432fe2ebd","permalink":"https://bixuanzju.github.io/talk/consistent-subtyping/","publishdate":"2017-01-01T00:00:00+08:00","relpermalink":"/talk/consistent-subtyping/","section":"talk","summary":"Consistent subtyping is employed in some gradual type systems to validate type conversions. The original definition by Siek and Taha serves as a guideline for designing many gradual type systems with subtyping. Polymorphic types `a la System F also induce a subtyping relation that relates polymorphic types to their instantiations. However Siek and Taha’s definition is not adequate for polymorphic subtyping. The first goal of this paper is to propose a generalization of consistent subtyping that is adequate for polymorphic subtyping, and subsumes the original definition by Siek and Taha. The new definition of consistent subtyping provides novel insights with respect to previous polymorphic gradual type systems, which did not employ consistent subtyping. The second goal of this paper is to present a gradually typed calculus for implicit (higher-rank) polymorphism that uses our new notion of consistent subtyping. We develop both declarative and (bi-directional) algorithmic versions for the type system. We prove that the new calculus satisfies all static aspects of the refined criteria for gradual typing, which are mechanically formalized using the Coq proof assistant.","tags":null,"title":"Consistent Subtyping for All","type":"talk"},{"authors":null,"categories":null,"date":1483200000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1533009520,"objectID":"77c557f64eca67305c383150d50f268c","permalink":"https://bixuanzju.github.io/talk/nested/","publishdate":"2017-01-01T00:00:00+08:00","relpermalink":"/talk/nested/","section":"talk","summary":"Calculi with disjoint intersection types support an introduction form for intersections called the merge operator, while retaining a coherent semantics. Disjoint intersections types have great potential to serve as a foundation for powerful, flexible and yet type-safe and easy to reason OO languages. This paper shows how to significantly increase the expressive power of disjoint intersection types by adding support for nested subtyping and composition, which enables simple forms of family polymorphism to be expressed in the calculus. The extension with nested sub- typing and composition is challenging, for two different reasons. Firstly, the subtyping relation that supports these features is non-trivial, especially when it comes to obtaining an algorithmic version. Secondly, the syntactic method used to prove coherence for previous calculi with disjoint intersection types is too inflexible, making it hard to extend those calculi with new features (such as nested subtyping). We show how to address the first problem by adapting and extending the Barendregt, Coppo and Dezani (BCD) subtyping rules for intersections with records and coercions. A sound and complete algorithmic system is obtained by using an approach inspired by Pierce’s work. To address the second problem we replace the syntactic method to prove coherence, by a semantic proof method based on logical relations. Our work has been fully formalized in Coq, and we have an implementation of our calculus.","tags":null,"title":"The Essence of Nested Composition","type":"talk"},{"authors":null,"categories":null,"date":1483200000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1533009520,"objectID":"98eedb8458f310ad89c6c734e80b4cd7","permalink":"https://bixuanzju.github.io/talk/traits/","publishdate":"2017-01-01T00:00:00+08:00","relpermalink":"/talk/traits/","section":"talk","summary":"Many dynamically typed languages (including JavaScript, Ruby, Python or Racket) support first-class classes, or related concepts such as first-class traits and/or mixins. In those languages classes are first-class values and, like any other values, they can be passed as an argument, or returned from a function. Furthermore first class classes support dynamic inheritance: i.e. they can inherit from other classes at runtime, enabling programmers to abstract over the inheritance hierarchy. In contrast, type system limitations prevent most statically typed languages from having first-class classes and dynamic inheritance. This paper shows the design of SEDEL: a polymorphic statically typed language with first- class traits, supporting dynamic inheritance as well as conventional OO features such as dynamic dispatching and abstract methods. The type system for SEDEL is based on the recent work on disjoint intersection types and disjoint polymorphism. However, such previous work is aimed at core calculi, and omits important features for practical OO languages, including (dynamic) inheritance, dynamic dispatching and abstract methods. This paper addresses that gap by showing how to model source language constructs for traits that support such missing features. Inspired by Cook’s work on the denotational semantics for inheritance, we show how to design a source language that can be elaborated into Alpuim et al.'s Fi which is a polymorphic calculus with records supporting disjoint polymorphism. We illustrate the applicability of SEDEL with several example uses for first-class traits, and a case study that modularizes programming language interpreters using a highly modular form of visitors.","tags":null,"title":"Typed First-Class Traits","type":"talk"},{"authors":["Yanpeng Yang","**Xuan Bi**","Bruno C. d. S. Oliveira"],"categories":null,"date":1472688000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1523527524,"objectID":"957576eaed19fd9deda5a314e792d3db","permalink":"https://bixuanzju.github.io/publication/unifed-syntax/","publishdate":"2016-09-01T00:00:00Z","relpermalink":"/publication/unifed-syntax/","section":"publication","summary":"Traditional designs for functional languages (such as Haskell or ML) have separate sorts of syntax for terms and types. In contrast, many dependently typed languages use a unified syntax that accounts for  both  terms  and  types.  Unified  syntax  has  some  interesting  advantages over  separate syntax,  including less  duplication  of concepts,  and added  expressiveness.  However,  integrating unrestricted general  recursion  in  calculi  with  unified  syntax  is  challenging  when  some  level  of type-level  computation  is  present,  as decidable type-checking is  easily lost. This paper argues that the advantages of unified syntax also apply to traditional functional languages, and there is no need to give up decidable type-checking. We present a dependently typed calculus that uses unified syntax, supports general recursion and has decidable type-checking. The key to retain decidable type-checking is a generalization of iso-recursive types called iso-types. Iso-types replace the conversion rule typically used in dependently typed calculus, and make every computation explicit via cast operators. We study two variants of the calculus that differ on the reduction  strategy  employed  by  the  cast  operators,  and  give  different trade-offs in terms of simplicity and expressiveness","tags":null,"title":"Unified Syntax with Iso-Types","type":"publication"},{"authors":null,"categories":null,"date":1460455303,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1528679497,"objectID":"c1f2f05fd40f0abfb70362081219b3c7","permalink":"https://bixuanzju.github.io/project/fcore/","publishdate":"2016-04-12T18:01:43+08:00","relpermalink":"/project/fcore/","section":"project","summary":"Research middleware compiler from System F-based languages to Java with the Imperative Functional Object encoding","tags":[],"title":"FCore","type":"project"},{"authors":["Tomas Tauber","**Xuan Bi**","Zhiyuan Shi","Weixin Zhang","Huang Li","Zhenrui Zhang","Bruno C. d. S. Oliveira"],"categories":null,"date":1441065600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1523549950,"objectID":"2dd2121bb9eb5b3f9b37b6c6d0db0717","permalink":"https://bixuanzju.github.io/publication/ifo/","publishdate":"2015-09-01T00:00:00Z","relpermalink":"/publication/ifo/","section":"publication","summary":"This paper presents FCore: a JVM implementation of System F with support for full tail-call elimination (TCE). Our compilation technique for FCore is innovative in two respects: it uses a new representation for first-class functions called imperative functional objects; and it provides a way to do TCE on the JVM using constant space. Unlike conventional TCE techniques on the JVM, allocated function objects are reused in chains of tail calls. Thus, programs written in FCore can use idiomatic functional programming styles, relying on TCE, and perform well without worrying about the JVM limitations. Our empirical results show that programs which use tail calls can run in constant space and with low execution time overhead when compiled with FCore.","tags":null,"title":"Memory-efficient Tail Calls in the JVM with Imperative Functional Objects","type":"publication"}]