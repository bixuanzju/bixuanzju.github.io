[{"authors":["admin"],"categories":null,"content":"I am currently a quantitative developer at Standard Chartered.\nI got my PhD in Computer Science from HKU PL Group advised by Dr. Bruno C. d. S. Oliveira. My research fields were programming languages, type systems and formal verification.\nDuring my PhD studies, I worked on a JVM implementation of System F with support for full tail-call elimination (see this paper for more). I worked on the design of a dependently-typed calculus featuring general recursion and decidable type-checking (see this paper for more). I also worked on the design of a gradual type system with support for implicit higher-rank polymorphism. Think of it as the first step towards Haskell-like languages with gradual typing (see this paper and also the journal version).\nMy PhD thesis is about the design of a type system featuring disjoint quantification and disjoint intersection types, which has great potential to serve as a foundation for powerful, flexible and yet type-safe and easy to reason object-oriented languages. See this paper and that for the theoretical foundation, and that for the first design of typed first-class traits.\n","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":-62135596800,"objectID":"598b63dd58b43bce02403646f240cd3c","permalink":"https://bixuanzju.github.io/authors/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/admin/","section":"author","summary":"I am currently a quantitative developer at Standard Chartered.\nI got my PhD in Computer Science from HKU PL Group advised by Dr. Bruno C. d. S. Oliveira. My research fields were programming languages, type systems and formal verification.\nDuring my PhD studies, I worked on a JVM implementation of System F with support for full tail-call elimination (see this paper for more). I worked on the design of a dependently-typed calculus featuring general recursion and decidable type-checking (see this paper for more).","tags":null,"title":"Xuan Bi","type":"author"},{"authors":null,"categories":null,"content":"Research middleware compiler from System F-based languages to Java with the Imperative Functional Object encoding\n","date":1551883624,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1551883624,"objectID":"c6a6429de2227f32030b80ef012bc307","permalink":"https://bixuanzju.github.io/project/fcore/","publishdate":"2019-03-06T22:47:04+08:00","relpermalink":"/project/fcore/","section":"project","summary":"Research middleware compiler from System F-based languages to Java with the Imperative Functional Object encoding","tags":["haskell","type-system"],"title":"FCore","type":"project"},{"authors":null,"categories":null,"content":"Coq formalization and implementation of the Fi+ calculus\n","date":1551883367,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1551883367,"objectID":"cdb1378949a74a4b1494a5dfe07bdfc8","permalink":"https://bixuanzju.github.io/project/fii/","publishdate":"2019-03-06T22:42:47+08:00","relpermalink":"/project/fii/","section":"project","summary":"Coq formalization and implementation of the Fi+ calculus","tags":["haskell","coq","type-system"],"title":"Fi+","type":"project"},{"authors":null,"categories":null,"content":"Haskell implementation of a type system for first-class traits\n","date":1551883107,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1551883107,"objectID":"68f37dd1b2fa350348d70f887055ec39","permalink":"https://bixuanzju.github.io/project/sedel/","publishdate":"2019-03-06T22:38:27+08:00","relpermalink":"/project/sedel/","section":"project","summary":"Haskell implementation of a type system for first-class traits","tags":["haskell","type-system"],"title":"SEDEL","type":"project"},{"authors":null,"categories":null,"content":"Haskell implementation of Gradually Polymorphic Calculus\n","date":1551882858,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1551882858,"objectID":"9c2cb6668b879040302dff6f9bce9603","permalink":"https://bixuanzju.github.io/project/gpc/","publishdate":"2019-03-06T22:34:18+08:00","relpermalink":"/project/gpc/","section":"project","summary":"Haskell implementation of Gradually Polymorphic Calculus","tags":["gradual-typing","haskell"],"title":"GPC","type":"project"},{"authors":null,"categories":null,"content":"Coq formalization of a coherent calculus with records and disjoint intersection types that supports nested composition\n","date":1551882636,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1551882636,"objectID":"6e36936923a967f3daa02a8f8de03820","permalink":"https://bixuanzju.github.io/project/nested/","publishdate":"2019-03-06T22:30:36+08:00","relpermalink":"/project/nested/","section":"project","summary":"Coq formalization of a coherent calculus with records and disjoint intersection types that supports nested composition","tags":["disjoint-intersection-type","coq","haskell"],"title":"NeColus","type":"project"},{"authors":["**Xuan Bi**","Ningning Xie","Bruno C. d. S. Oliveira","Tom Schrijvers"],"categories":null,"content":"","date":1548460800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1548460800,"objectID":"95d15ef2290609de4d4d95efe6c2598c","permalink":"https://bixuanzju.github.io/publication/bi-2019-dis/","publishdate":"2019-01-26T00:00:00Z","relpermalink":"/publication/bi-2019-dis/","section":"publication","summary":"Popular programming techniques such as shallow embeddings of Domain Specific Languages (DSLs), finally tagless or object algebras are built on the principle of compositionality. However, existing programming languages only support simple compositional designs well, and have limited support for more sophisticated ones. This paper presents the F+i calculus, which supports highly modular and compositional designs that improve on existing techniques. These improvements are due to the combination of three features: disjoint intersection types with a merge operator; parametric (disjoint) polymorphism; and BCD-style distributive subtyping. The main technical challenge is F+i's proof of coherence. A naive adaptation of ideas used in System F's parametricity to canonicity (the logical relation used by F+i to prove coherence) results in an ill-founded logical relation. To solve the problem our canonicity relation employs a different technique based on immediate substitutions and a restriction to predicative instantiations. Besides coherence, we show several other important meta-theoretical results, such as type-safety, sound and complete algorithmic subtyping, and decidability of the type system. Remarkably, unlike F","tags":["type-system","disjoint-intersection-type"],"title":"Distributive Disjoint Polymorphism for Compositional Programming","type":"publication"},{"authors":["Ningning Xie","**Xuan Bi**","Bruno C. d. S. Oliveira","Tom Schrijvers"],"categories":null,"content":"","date":1547596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1547596800,"objectID":"2b61030b6afe75a9af221f6ee0e81d90","permalink":"https://bixuanzju.github.io/publication/xie-2019-toplas/","publishdate":"2019-01-16T00:00:00Z","relpermalink":"/publication/xie-2019-toplas/","section":"publication","summary":"Consistent subtyping is employed in some gradual type systems to validate type conversions. The original definition by Siek and Taha serves as a guideline for designing gradual type systems with subtyping. Polymorphic types à la System F also induce a subtyping relation that relates polymorphic types to their instantiations. However Siek and Taha's definition is not adequate for polymorphic subtyping. The first goal of this paper is to propose a generalization of consistent subtyping that is adequate for polymorphic subtyping, and subsumes the original definition by Siek and Taha. The new definition of consistent subtyping provides novel insights with respect to previous polymorphic gradual type systems, which did not employ consistent subtyping. The second goal of this paper is to present a gradually typed calculus for implicit (higher-rank) polymorphism that uses our new notion of consistent subtyping. We develop both declarative and (bidirectional) algorithmic versions for the type system. The algorithmic version employs techniques developed by Dunfield and Krishnaswami to deal with instantiation. We prove that the new calculus satisfies all static aspects of the refined criteria for gradual typing. We also study an extension of the type system with static and gradual type parameters, in an attempt to support a variant of the dynamic criterion for gradual typing. Armed with a coherence conjecture for the extended calculus, we show that the dynamic gradual guarantee of our source language can be reduced to that of λB, which, at the time of writing, is still an open question. Most of the metatheory of this paper, except some manual proofs for the algorithmic type system and extensions, has been mechanically formalized using the Coq proof assistant.","tags":["type-system","gradual-typing"],"title":"Consistent Subtyping for All","type":"publication"},{"authors":["Xuan Bi"],"categories":null,"content":"","date":1532101800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1532101800,"objectID":"2c8809a33e7c86561bc6b507db5fd903","permalink":"https://bixuanzju.github.io/talk/nested/","publishdate":"2019-03-06T22:17:53+08:00","relpermalink":"/talk/nested/","section":"talk","summary":"Calculi with disjoint intersection types support an introduction form for intersections called the merge operator, while retaining a coherent semantics. Disjoint intersections types have great potential to serve as a foundation for powerful, flexible and yet type-safe and easy to reason OO languages. This paper shows how to significantly increase the expressive power of disjoint intersection types by adding support for nested subtyping and composition, which enables simple forms of family polymorphism to be expressed in the calculus. The extension with nested sub- typing and composition is challenging, for two different reasons. Firstly, the subtyping relation that supports these features is non-trivial, especially when it comes to obtaining an algorithmic version. Secondly, the syntactic method used to prove coherence for previous calculi with disjoint intersection types is too inflexible, making it hard to extend those calculi with new features (such as nested subtyping). We show how to address the first problem by adapting and extending the Barendregt, Coppo and Dezani (BCD) subtyping rules for intersections with records and coercions. A sound and complete algorithmic system is obtained by using an approach inspired by Pierce’s work. To address the second problem we replace the syntactic method to prove coherence, by a semantic proof method based on logical relations. Our work has been fully formalized in Coq, and we have an implementation of our calculus.","tags":["disjoint-intersection-type","type-system"],"title":"The Essence of Nested Composition","type":"talk"},{"authors":["**Xuan Bi**","Bruno C. d. S. Oliveira","Tom Schrijvers"],"categories":null,"content":"","date":1532044800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1532044800,"objectID":"7ddbc88fd6e961362ad3ac8c491b97d8","permalink":"https://bixuanzju.github.io/publication/bi-2018-essence/","publishdate":"2018-07-20T00:00:00Z","relpermalink":"/publication/bi-2018-essence/","section":"publication","summary":"Calculi with disjoint intersection types support an introduction form for intersections called the merge operator, while retaining a coherent semantics. Disjoint intersections types have great potential to serve as a foundation for powerful, flexible and yet type-safe and easy to reason OO languages. This paper shows how to significantly increase the expressive power of disjoint intersection types by adding support for nested subtyping and composition, which enables simple forms of family polymorphism to be expressed in the calculus. The extension with nested subtyping and composition is challenging, for two different reasons. Firstly, the subtyping relation that supports these features is non-trivial, especially when it comes to obtaining an algorithmic version. Secondly, the syntactic method used to prove coherence for previous calculi with disjoint intersection types is too inflexible, making it hard to extend those calculi with new features (such as nested subtyping). We show how to address the first problem by adapting and extending the Barendregt, Coppo and Dezani (BCD) subtyping rules for intersections with records and coercions. A sound and complete algorithmic system is obtained by using an approach inspired by Pierce’s work. To address the second problem we replace the syntactic method to prove coherence, by a semantic proof method based on logical relations. Our work has been fully formalized in Coq, and we have an implementation of our calculus.","tags":["type-system","disjoint-intersection-type"],"title":"The Essence of Nested Composition","type":"publication"},{"authors":["**Xuan Bi**","Bruno C. d. S. Oliveira"],"categories":null,"content":"","date":1532044800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1532044800,"objectID":"ba2119d379d69936521d7ef999bca027","permalink":"https://bixuanzju.github.io/publication/bi-2018-typed/","publishdate":"2018-07-20T00:00:00Z","relpermalink":"/publication/bi-2018-typed/","section":"publication","summary":"Many dynamically typed languages (including JavaScript, Ruby, Python or Racket) support first-class classes, or related concepts such as first-class traits and/or mixins. In those languages classes are first-class values and, like any other values, they can be passed as an argument, or returned from a function. Furthermore first class classes support dynamic inheritance: i.e. they can inherit from other classes at runtime, enabling programmers to abstract over the inheritance hierarchy. In contrast, type system limitations prevent most statically typed languages from having first-class classes and dynamic inheritance. This paper shows the design of SEDEL: a polymorphic statically typed language with first- class traits, supporting dynamic inheritance as well as conventional OO features such as dynamic dispatching and abstract methods. The type system for SEDEL is based on the recent work on disjoint intersection types and disjoint polymorphism. However, such previous work is aimed at core calculi, and omits important features for practical OO languages, including (dynamic) inheritance, dynamic dispatching and abstract methods. This paper addresses that gap by showing how to model source language constructs for traits that support such missing features. Inspired by Cook’s work on the denotational semantics for inheritance, we show how to design a source language that can be elaborated into Alpuim et al.'s Fi which is a polymorphic calculus with records supporting disjoint polymorphism. We illustrate the applicability of SEDEL with several example uses for first-class traits, and a case study that modularizes programming language interpreters using a highly modular form of visitors.","tags":["type-system","disjoint-intersection-type"],"title":"Typed First-Class Traits","type":"publication"},{"authors":["Xuan Bi"],"categories":null,"content":"","date":1532012400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1532012400,"objectID":"b8ce65b4267492e0240cfaaef14e2df3","permalink":"https://bixuanzju.github.io/talk/traits/","publishdate":"2019-03-06T22:18:02+08:00","relpermalink":"/talk/traits/","section":"talk","summary":"Many dynamically typed languages (including JavaScript, Ruby, Python or Racket) support first-class classes, or related concepts such as first-class traits and/or mixins. In those languages classes are first-class values and, like any other values, they can be passed as an argument, or returned from a function. Furthermore first class classes support dynamic inheritance: i.e. they can inherit from other classes at runtime, enabling programmers to abstract over the inheritance hierarchy. In contrast, type system limitations prevent most statically typed languages from having first-class classes and dynamic inheritance. This paper shows the design of SEDEL: a polymorphic statically typed language with first- class traits, supporting dynamic inheritance as well as conventional OO features such as dynamic dispatching and abstract methods. The type system for SEDEL is based on the recent work on disjoint intersection types and disjoint polymorphism. However, such previous work is aimed at core calculi, and omits important features for practical OO languages, including (dynamic) inheritance, dynamic dispatching and abstract methods. This paper addresses that gap by showing how to model source language constructs for traits that support such missing features. Inspired by Cook’s work on the denotational semantics for inheritance, we show how to design a source language that can be elaborated into Alpuim et al.'s Fi which is a polymorphic calculus with records supporting disjoint polymorphism. We illustrate the applicability of SEDEL with several example uses for first-class traits, and a case study that modularizes programming language interpreters using a highly modular form of visitors.","tags":["type-system"],"title":"Typed First-Class Traits","type":"talk"},{"authors":["Xuan Bi"],"categories":null,"content":"","date":1523867400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1523867400,"objectID":"f0aa94c7bcea7edbaa2eab6a64149e31","permalink":"https://bixuanzju.github.io/talk/consistent-subtyping/","publishdate":"2019-03-06T22:10:48+08:00","relpermalink":"/talk/consistent-subtyping/","section":"talk","summary":"Consistent subtyping is employed in some gradual type systems to validate type conversions. The original definition by Siek and Taha serves as a guideline for designing many gradual type systems with subtyping. Polymorphic types `a la System F also induce a subtyping relation that relates polymorphic types to their instantiations. However Siek and Taha’s definition is not adequate for polymorphic subtyping. The first goal of this paper is to propose a generalization of consistent subtyping that is adequate for polymorphic subtyping, and subsumes the original definition by Siek and Taha. The new definition of consistent subtyping provides novel insights with respect to previous polymorphic gradual type systems, which did not employ consistent subtyping. The second goal of this paper is to present a gradually typed calculus for implicit (higher-rank) polymorphism that uses our new notion of consistent subtyping. We develop both declarative and (bi-directional) algorithmic versions for the type system. We prove that the new calculus satisfies all static aspects of the refined criteria for gradual typing, which are mechanically formalized using the Coq proof assistant.","tags":["gradual-typing","type-system"],"title":"Consistent Subtyping for All","type":"talk"},{"authors":["Ningning Xie","**Xuan Bi**","Bruno C. d. S. Oliveira"],"categories":null,"content":"","date":1520726400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1520726400,"objectID":"18056496542434e510beb4b9b23e8659","permalink":"https://bixuanzju.github.io/publication/xie-2018-consistent/","publishdate":"2018-03-11T00:00:00Z","relpermalink":"/publication/xie-2018-consistent/","section":"publication","summary":"Consistent subtyping is employed in some gradual type systems to validate type conversions. The original definition by Siek and Taha serves as a guideline for designing many gradual type systems with subtyping. Polymorphic types `a la System F also induce a subtyping relation that relates polymorphic types to their instantiations. However Siek and Taha’s definition is not adequate for polymorphic subtyping. The first goal of this paper is to propose a generalization of consistent subtyping that is adequate for polymorphic subtyping, and subsumes the original definition by Siek and Taha. The new definition of consistent subtyping provides novel insights with respect to previous polymorphic gradual type systems, which did not employ consistent subtyping. The second goal of this paper is to present a gradually typed calculus for implicit (higher-rank) polymorphism that uses our new notion of consistent subtyping. We develop both declarative and (bi-directional) algorithmic versions for the type system. We prove that the new calculus satisfies all static aspects of the refined criteria for gradual typing, which are mechanically formalized using the Coq proof assistant.","tags":["type-system","gradual-typing"],"title":"Consistent Subtyping for All","type":"publication"},{"authors":["Yanpeng Yang","**Xuan Bi**","Bruno C. d. S. Oliveira"],"categories":null,"content":"","date":1472688000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1472688000,"objectID":"692d38b8e822ff52044be8f645c1918f","permalink":"https://bixuanzju.github.io/publication/yang-2016-unified/","publishdate":"2016-09-01T00:00:00Z","relpermalink":"/publication/yang-2016-unified/","section":"publication","summary":"Traditional designs for functional languages (such as Haskell or ML) have separate sorts of syntax for terms and types. In contrast, many dependently typed languages use a unified syntax that accounts for  both  terms  and  types.  Unified  syntax  has  some  interesting  advantages over  separate syntax,  including less  duplication  of concepts,  and added  expressiveness.  However,  integrating unrestricted general  recursion  in  calculi  with  unified  syntax  is  challenging  when  some  level  of type-level  computation  is  present,  as decidable type-checking is  easily lost. This paper argues that the advantages of unified syntax also apply to traditional functional languages, and there is no need to give up decidable type-checking. We present a dependently typed calculus that uses unified syntax, supports general recursion and has decidable type-checking. The key to retain decidable type-checking is a generalization of iso-recursive types called iso-types. Iso-types replace the conversion rule typically used in dependently typed calculus, and make every computation explicit via cast operators. We study two variants of the calculus that differ on the reduction  strategy  employed  by  the  cast  operators,  and  give  different trade-offs in terms of simplicity and expressiveness","tags":["type-system","dependent-type"],"title":"Unified Syntax with Iso-Types","type":"publication"},{"authors":["Tomas Tauber","**Xuan Bi**","Zhiyuan Shi","Weixin Zhang","Huang Li","Zhenrui Zhang","Bruno C. d. S. Oliveira"],"categories":null,"content":"","date":1441065600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1441065600,"objectID":"600a3412a442b75d7faae5419bd475a2","permalink":"https://bixuanzju.github.io/publication/tauber-2015-memory/","publishdate":"2015-09-01T00:00:00Z","relpermalink":"/publication/tauber-2015-memory/","section":"publication","summary":"This paper presents FCore: a JVM implementation of System F with support for full tail-call elimination (TCE). Our compilation technique for FCore is innovative in two respects: it uses a new representation for first-class functions called imperative functional objects; and it provides a way to do TCE on the JVM using constant space. Unlike conventional TCE techniques on the JVM, allocated function objects are reused in chains of tail calls. Thus, programs written in FCore can use idiomatic functional programming styles, relying on TCE, and perform well without worrying about the JVM limitations. Our empirical results show that programs which use tail calls can run in constant space and with low execution time overhead when compiled with FCore.","tags":["type-system"],"title":"Memory-efficient Tail Calls in the JVM with Imperative Functional Objects","type":"publication"},{"authors":["Xi Chen","Huajun Chen","**Xuan Bi**","Peiqin Gu","Jiaoyan Chen","Zhaohui Wu"],"categories":null,"content":"","date":1388534400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1388534400,"objectID":"4b3cf86f2370515918dd40296b3426ce","permalink":"https://bixuanzju.github.io/publication/chen-2014-biotcm/","publishdate":"2014-01-01T00:00:00Z","relpermalink":"/publication/chen-2014-biotcm/","section":"publication","summary":"Understanding the functional mechanisms of the complex biological system as a whole is drawing more and more attention in global health care management. Traditional Chinese Medicine (TCM), essentially different from Western Medicine (WM), is gaining increasing attention due to its emphasis on individual wellness and natural herbal medicine, which satisfies the goal of integrative medicine. However, with the explosive growth of biomedical data on the Web, biomedical researchers are now confronted with the problem of large-scale data analysis and data query. Besides that, biomedical data also has a wide coverage which usually comes from multiple heterogeneous data sources and has different taxonomies, making it hard to integrate and query the big biomedical data. Embedded with domain knowledge from different disciplines all regarding human biological systems, the heterogeneous data repositories are implicitly connected by human expert knowledge. Traditional search engines cannot provide accurate and comprehensive search results for the semantically associated knowledge since they only support keywords-based searches. In this paper, we present BioTCM-SE, a semantic search engine for the information retrieval of modern biology and TCM, which provides biologists with a comprehensive and accurate associated knowledge query platform to greatly facilitate the implicit knowledge discovery between WM and TCM.","tags":[],"title":"BioTCM-SE: a semantic search engine for the information retrieval of modern biology and traditional Chinese medicine","type":"publication"}]