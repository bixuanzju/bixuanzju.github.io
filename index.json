[{"authors":null,"categories":null,"content":"I am currently a quantitative developer at Standard Chartered.\nI got my PhD in Computer Science from HKU PL Group advised by Dr. Bruno C. d. S. Oliveira. My research fields were programming languages, type systems and formal verification.\nDuring my PhD studies, I worked on a JVM implementation of System F with support for full tail-call elimination (see this paper for more). I worked on the design of a dependently-typed calculus featuring general recursion and decidable type-checking (see this paper for more). I also worked on the design of a gradual type system with support for implicit higher-rank polymorphism. Think of it as the first step towards Haskell-like languages with gradual typing (see this paper and also the journal version).\nMy PhD thesis is about the design of a type system featuring disjoint quantification and disjoint intersection types, which has great potential to serve as a foundation for powerful, flexible and yet type-safe and easy to reason object-oriented languages. See this paper and that for the theoretical foundation, and that for the first design of typed first-class traits.\n","date":1605398400,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":1607817600,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"","publishdate":"0001-01-01T00:00:00Z","relpermalink":"","section":"authors","summary":"I am currently a quantitative developer at Standard Chartered.\nI got my PhD in Computer Science from HKU PL Group advised by Dr. Bruno C. d. S. Oliveira. My research fields were programming languages, type systems and formal verification.","tags":null,"title":"(Jeremy) Xuan Bi","type":"authors"},{"authors":["Ningning Xie","Bruno C. d. S. Oliveira","(Jeremy) Xuan Bi","Tom Schrijvers"],"categories":null,"content":"","date":1605398400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1605398400,"objectID":"52813e02235acefcaf1c381be1496c91","permalink":"https://bixuanzju.github.io/publication/xie-2020-ecoop/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/publication/xie-2020-ecoop/","section":"publication","summary":"Polymorphism and subtyping are important features in mainstream OO languages. The most common way to integrate the two is via F","tags":["type-system","disjoint-intersection-type"],"title":"Row and Bounded Polymorphism via Disjoint Polymorphism","type":"publication"},{"authors":null,"categories":null,"content":"Coq formalization and implementation of the Fi+ calculus\n","date":1551830400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1551830400,"objectID":"cdb1378949a74a4b1494a5dfe07bdfc8","permalink":"https://bixuanzju.github.io/project/fii/","publishdate":"2019-03-06T00:00:00Z","relpermalink":"/project/fii/","section":"project","summary":"Coq formalization and implementation of the Fi+ calculus","tags":["haskell","coq","type-system"],"title":"Fi+","type":"project"},{"authors":null,"categories":null,"content":"Haskell implementation of Gradually Polymorphic Calculus\n","date":1551830400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1551830400,"objectID":"9c2cb6668b879040302dff6f9bce9603","permalink":"https://bixuanzju.github.io/project/gpc/","publishdate":"2019-03-06T00:00:00Z","relpermalink":"/project/gpc/","section":"project","summary":"Haskell implementation of Gradually Polymorphic Calculus","tags":["gradual-typing","haskell"],"title":"GPC","type":"project"},{"authors":null,"categories":null,"content":"Coq formalization of a coherent calculus with records and disjoint intersection types that supports nested composition\n","date":1551830400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1551830400,"objectID":"6e36936923a967f3daa02a8f8de03820","permalink":"https://bixuanzju.github.io/project/nested/","publishdate":"2019-03-06T00:00:00Z","relpermalink":"/project/nested/","section":"project","summary":"Coq formalization of a coherent calculus with records and disjoint intersection types that supports nested composition","tags":["disjoint-intersection-type","coq","haskell"],"title":"NeColus","type":"project"},{"authors":null,"categories":null,"content":"Haskell implementation of a type system for first-class traits\n","date":1551830400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1551830400,"objectID":"68f37dd1b2fa350348d70f887055ec39","permalink":"https://bixuanzju.github.io/project/sedel/","publishdate":"2019-03-06T00:00:00Z","relpermalink":"/project/sedel/","section":"project","summary":"Haskell implementation of a type system for first-class traits","tags":["haskell","type-system"],"title":"SEDEL","type":"project"},{"authors":[],"categories":[],"content":"Create slides in Markdown with Wowchemy Wowchemy | Documentation\n Features  Efficiently write slides in Markdown 3-in-1: Create, Present, and Publish your slides Supports speaker notes Mobile friendly slides   Controls  Next: Right Arrow or Space Previous: Left Arrow Start: Home Finish: End Overview: Esc Speaker notes: S Fullscreen: F Zoom: Alt + Click PDF Export: E   Code Highlighting Inline code: variable\nCode block:\nporridge = \u0026quot;blueberry\u0026quot; if porridge == \u0026quot;blueberry\u0026quot;: print(\u0026quot;Eating...\u0026quot;)   Math In-line math: $x + y = z$\nBlock math:\n$$ f\\left( x \\right) = ;\\frac{{2\\left( {x + 4} \\right)\\left( {x - 4} \\right)}}{{\\left( {x + 4} \\right)\\left( {x + 1} \\right)}} $$\n Fragments Make content appear incrementally\n{{% fragment %}} One {{% /fragment %}} {{% fragment %}} **Two** {{% /fragment %}} {{% fragment %}} Three {{% /fragment %}}  Press Space to play!\nOne  Two  Three \n A fragment can accept two optional parameters:\n class: use a custom style (requires definition in custom CSS) weight: sets the order in which a fragment appears   Speaker Notes Add speaker notes to your presentation\n{{% speaker_note %}} - Only the speaker can read these notes - Press `S` key to view {{% /speaker_note %}}  Press the S key to view the speaker notes!\n Only the speaker can read these notes Press S key to view    Themes  black: Black background, white text, blue links (default) white: White background, black text, blue links league: Gray background, white text, blue links beige: Beige background, dark text, brown links sky: Blue background, thin dark text, blue links    night: Black background, thick white text, orange links serif: Cappuccino background, gray text, brown links simple: White background, black text, blue links solarized: Cream-colored background, dark green text, blue links   Custom Slide Customize the slide style and background\n{{\u0026lt; slide background-image=\u0026quot;/media/boards.jpg\u0026quot; \u0026gt;}} {{\u0026lt; slide background-color=\u0026quot;#0000FF\u0026quot; \u0026gt;}} {{\u0026lt; slide class=\u0026quot;my-style\u0026quot; \u0026gt;}}   Custom CSS Example Let\u0026rsquo;s make headers navy colored.\nCreate assets/css/reveal_custom.css with:\n.reveal section h1, .reveal section h2, .reveal section h3 { color: navy; }   Questions? Ask\nDocumentation\n","date":1549324800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1549324800,"objectID":"0e6de1a61aa83269ff13324f3167c1a9","permalink":"https://bixuanzju.github.io/slides/example/","publishdate":"2019-02-05T00:00:00Z","relpermalink":"/slides/example/","section":"slides","summary":"An introduction to using Wowchemy's Slides feature.","tags":[],"title":"Slides","type":"slides"},{"authors":["(Jeremy) Xuan Bi","Ningning Xie","Bruno C. d. S. Oliveira","Tom Schrijvers"],"categories":null,"content":"","date":1548460800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1548460800,"objectID":"95d15ef2290609de4d4d95efe6c2598c","permalink":"https://bixuanzju.github.io/publication/bi-2019-dis/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/publication/bi-2019-dis/","section":"publication","summary":"Popular programming techniques such as shallow embeddings of Domain Specific Languages (DSLs), finally tagless or object algebras are built on the principle of compositionality. However, existing programming languages only support simple compositional designs well, and have limited support for more sophisticated ones. This paper presents the F+i calculus, which supports highly modular and compositional designs that improve on existing techniques. These improvements are due to the combination of three features -- disjoint intersection types with a merge operator; parametric (disjoint) polymorphism; and BCD-style distributive subtyping. The main technical challenge is F+i's proof of coherence. A naive adaptation of ideas used in System F's parametricity to canonicity (the logical relation used by F+i to prove coherence) results in an ill-founded logical relation. To solve the problem our canonicity relation employs a different technique based on immediate substitutions and a restriction to predicative instantiations. Besides coherence, we show several other important meta-theoretical results, such as type-safety, sound and complete algorithmic subtyping, and decidability of the type system. Remarkably, unlike F","tags":["type-system","disjoint-intersection-type"],"title":"Distributive Disjoint Polymorphism for Compositional Programming","type":"publication"},{"authors":["Ningning Xie","(Jeremy) Xuan Bi","Bruno C. d. S. Oliveira","Tom Schrijvers"],"categories":null,"content":"","date":1547596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1547596800,"objectID":"2b61030b6afe75a9af221f6ee0e81d90","permalink":"https://bixuanzju.github.io/publication/xie-2019-toplas/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/publication/xie-2019-toplas/","section":"publication","summary":"Consistent subtyping is employed in some gradual type systems to validate type conversions. The original definition by Siek and Taha serves as a guideline for designing gradual type systems with subtyping. Polymorphic types à la System F also induce a subtyping relation that relates polymorphic types to their instantiations. However Siek and Taha's definition is not adequate for polymorphic subtyping. The first goal of this paper is to propose a generalization of consistent subtyping that is adequate for polymorphic subtyping, and subsumes the original definition by Siek and Taha. The new definition of consistent subtyping provides novel insights with respect to previous polymorphic gradual type systems, which did not employ consistent subtyping. The second goal of this paper is to present a gradually typed calculus for implicit (higher-rank) polymorphism that uses our new notion of consistent subtyping. We develop both declarative and (bidirectional) algorithmic versions for the type system. The algorithmic version employs techniques developed by Dunfield and Krishnaswami to deal with instantiation. We prove that the new calculus satisfies all static aspects of the refined criteria for gradual typing. We also study an extension of the type system with static and gradual type parameters, in an attempt to support a variant of the dynamic criterion for gradual typing. Armed with a coherence conjecture for the extended calculus, we show that the dynamic gradual guarantee of our source language can be reduced to that of λB, which, at the time of writing, is still an open question. Most of the metatheory of this paper, except some manual proofs for the algorithmic type system and extensions, has been mechanically formalized using the Coq proof assistant.","tags":["type-system","gradual-typing"],"title":"Consistent Subtyping for All","type":"publication"},{"authors":["(Jeremy) Xuan Bi"],"categories":null,"content":"","date":1545350400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1545350400,"objectID":"0f40cf545adf79432be77d9037b7794b","permalink":"https://bixuanzju.github.io/publication/thesis/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/publication/thesis/","section":"publication","summary":"Programs are hard to write. It was so 50 years ago at the time of the so-called software crisis; it still remains so nowadays. Over the years, we have learned---the hard way---that software should be constructed in a modular way, i.e., as a network of smaller and loosely connected modules. To facilitate writing modular code, researchers and software practitioners have developed new methodologies; new programming paradigms; stronger type systems; as well as better tooling support. Still, this is not enough to cope with today’s needs. Several reasons have been raised for the lack of satisfactory solutions, but one that is constantly pointed out is the inadequacy of existing programming languages for the construction of modular software. This thesis investigates disjoint intersection types, a variant of intersection types. Disjoint intersections types have great potential to serve as a foundation for powerful, flexible and yet type-safe and easy to reason OO languages, suitable for writing modular software. On the theoretical side, this thesis shows how to significantly increase the expressiveness of disjoint intersection types by adding support for nested composition, along with parametric polymorphism. Nested composition extends inheritance to work on a whole family of classes, enabling high degrees of modularity and code reuse. The combination with parametric polymorphism further improves the state-of-art encodings of extensible designs. However, the extension with nested composition and parametric polymorphism is challenging, for two different reasons. Firstly, the subtyping relation that supports these features is non-trivial. Secondly, the syntactic method used to prove coherence for previous calculi with disjoint intersection types is too inflexible. This thesis addresses the first problem by adapting and extending the well-known BCD subtyping with records, universal quantification and coercions. To address the second problem, this thesis proposes a powerful proof method to establish coherence. Hence, this thesis puts disjoint intersection types on a solid footing by thoroughly exploring their meta-theoretical properties.","tags":["type-system","disjoint-intersection"],"title":"Disjoint Intersection Types: Theory and Practice","type":"publication"},{"authors":["(Jeremy) Xuan Bi"],"categories":null,"content":"","date":1532101800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1532101800,"objectID":"2c8809a33e7c86561bc6b507db5fd903","permalink":"https://bixuanzju.github.io/talk/nested/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/talk/nested/","section":"talk","summary":"Calculi with disjoint intersection types support an introduction form for intersections called the merge operator, while retaining a coherent semantics. Disjoint intersections types have great potential to serve as a foundation for powerful, flexible and yet type-safe and easy to reason OO languages. This paper shows how to significantly increase the expressive power of disjoint intersection types by adding support for nested subtyping and composition, which enables simple forms of family polymorphism to be expressed in the calculus. The extension with nested sub- typing and composition is challenging, for two different reasons. Firstly, the subtyping relation that supports these features is non-trivial, especially when it comes to obtaining an algorithmic version. Secondly, the syntactic method used to prove coherence for previous calculi with disjoint intersection types is too inflexible, making it hard to extend those calculi with new features (such as nested subtyping). We show how to address the first problem by adapting and extending the Barendregt, Coppo and Dezani (BCD) subtyping rules for intersections with records and coercions. A sound and complete algorithmic system is obtained by using an approach inspired by Pierce’s work. To address the second problem we replace the syntactic method to prove coherence, by a semantic proof method based on logical relations. Our work has been fully formalized in Coq, and we have an implementation of our calculus.","tags":["disjoint-intersection-type","type-system"],"title":"The Essence of Nested Composition","type":"talk"},{"authors":["(Jeremy) Xuan Bi","Bruno C. d. S. Oliveira","Tom Schrijvers"],"categories":null,"content":"","date":1532044800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1532044800,"objectID":"7ddbc88fd6e961362ad3ac8c491b97d8","permalink":"https://bixuanzju.github.io/publication/bi-2018-essence/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/publication/bi-2018-essence/","section":"publication","summary":"Calculi with disjoint intersection types support an introduction form for intersections called the merge operator, while retaining a coherent semantics. Disjoint intersections types have great potential to serve as a foundation for powerful, flexible and yet type-safe and easy to reason OO languages. This paper shows how to significantly increase the expressive power of disjoint intersection types by adding support for nested subtyping and composition, which enables simple forms of family polymorphism to be expressed in the calculus. The extension with nested subtyping and composition is challenging, for two different reasons. Firstly, the subtyping relation that supports these features is non-trivial, especially when it comes to obtaining an algorithmic version. Secondly, the syntactic method used to prove coherence for previous calculi with disjoint intersection types is too inflexible, making it hard to extend those calculi with new features (such as nested subtyping). We show how to address the first problem by adapting and extending the Barendregt, Coppo and Dezani (BCD) subtyping rules for intersections with records and coercions. A sound and complete algorithmic system is obtained by using an approach inspired by Pierce’s work. To address the second problem we replace the syntactic method to prove coherence, by a semantic proof method based on logical relations. Our work has been fully formalized in Coq, and we have an implementation of our calculus.","tags":["type-system","disjoint-intersection-type"],"title":"The Essence of Nested Composition","type":"publication"},{"authors":["(Jeremy) Xuan Bi","Bruno C. d. S. Oliveira"],"categories":null,"content":"","date":1532044800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1532044800,"objectID":"ba2119d379d69936521d7ef999bca027","permalink":"https://bixuanzju.github.io/publication/bi-2018-typed/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/publication/bi-2018-typed/","section":"publication","summary":"Many dynamically typed languages (including JavaScript, Ruby, Python or Racket) support first-class classes, or related concepts such as first-class traits and/or mixins. In those languages classes are first-class values and, like any other values, they can be passed as an argument, or returned from a function. Furthermore first class classes support dynamic inheritance, i.e. they can inherit from other classes at runtime, enabling programmers to abstract over the inheritance hierarchy. In contrast, type system limitations prevent most statically typed languages from having first-class classes and dynamic inheritance. This paper shows the design of SEDEL -- a polymorphic statically typed language with first- class traits, supporting dynamic inheritance as well as conventional OO features such as dynamic dispatching and abstract methods. The type system for SEDEL is based on the recent work on disjoint intersection types and disjoint polymorphism. However, such previous work is aimed at core calculi, and omits important features for practical OO languages, including (dynamic) inheritance, dynamic dispatching and abstract methods. This paper addresses that gap by showing how to model source language constructs for traits that support such missing features. Inspired by Cook’s work on the denotational semantics for inheritance, we show how to design a source language that can be elaborated into Alpuim et al.'s Fi which is a polymorphic calculus with records supporting disjoint polymorphism. We illustrate the applicability of SEDEL with several example uses for first-class traits, and a case study that modularizes programming language interpreters using a highly modular form of visitors.","tags":["type-system","disjoint-intersection-type"],"title":"Typed First-Class Traits","type":"publication"},{"authors":["(Jeremy) Xuan Bi"],"categories":null,"content":"","date":1532012400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1532012400,"objectID":"b8ce65b4267492e0240cfaaef14e2df3","permalink":"https://bixuanzju.github.io/talk/traits/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/talk/traits/","section":"talk","summary":"Many dynamically typed languages (including JavaScript, Ruby, Python or Racket) support first-class classes, or related concepts such as first-class traits and/or mixins. In those languages classes are first-class values and, like any other values, they can be passed as an argument, or returned from a function. Furthermore first class classes support dynamic inheritance: i.e. they can inherit from other classes at runtime, enabling programmers to abstract over the inheritance hierarchy. In contrast, type system limitations prevent most statically typed languages from having first-class classes and dynamic inheritance. This paper shows the design of SEDEL: a polymorphic statically typed language with first- class traits, supporting dynamic inheritance as well as conventional OO features such as dynamic dispatching and abstract methods. The type system for SEDEL is based on the recent work on disjoint intersection types and disjoint polymorphism. However, such previous work is aimed at core calculi, and omits important features for practical OO languages, including (dynamic) inheritance, dynamic dispatching and abstract methods. This paper addresses that gap by showing how to model source language constructs for traits that support such missing features. Inspired by Cook’s work on the denotational semantics for inheritance, we show how to design a source language that can be elaborated into Alpuim et al.'s Fi which is a polymorphic calculus with records supporting disjoint polymorphism. We illustrate the applicability of SEDEL with several example uses for first-class traits, and a case study that modularizes programming language interpreters using a highly modular form of visitors.","tags":["disjoint-intersection-type","type-system"],"title":"Typed First-Class Traits","type":"talk"},{"authors":["(Jeremy) Xuan Bi"],"categories":null,"content":"","date":1523867400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1523867400,"objectID":"f0aa94c7bcea7edbaa2eab6a64149e31","permalink":"https://bixuanzju.github.io/talk/consistent-subtyping/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/talk/consistent-subtyping/","section":"talk","summary":"Consistent subtyping is employed in some gradual type systems to validate type conversions. The original definition by Siek and Taha serves as a guideline for designing many gradual type systems with subtyping. Polymorphic types `a la System F also induce a subtyping relation that relates polymorphic types to their instantiations. However Siek and Taha’s definition is not adequate for polymorphic subtyping. The first goal of this paper is to propose a generalization of consistent subtyping that is adequate for polymorphic subtyping, and subsumes the original definition by Siek and Taha. The new definition of consistent subtyping provides novel insights with respect to previous polymorphic gradual type systems, which did not employ consistent subtyping. The second goal of this paper is to present a gradually typed calculus for implicit (higher-rank) polymorphism that uses our new notion of consistent subtyping. We develop both declarative and (bi-directional) algorithmic versions for the type system. We prove that the new calculus satisfies all static aspects of the refined criteria for gradual typing, which are mechanically formalized using the Coq proof assistant.","tags":["gradual-typing","type-system"],"title":"Consistent Subtyping for All","type":"talk"},{"authors":["Ningning Xie","(Jeremy) Xuan Bi","Bruno C. d. S. Oliveira"],"categories":null,"content":"","date":1520726400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1520726400,"objectID":"18056496542434e510beb4b9b23e8659","permalink":"https://bixuanzju.github.io/publication/xie-2018-consistent/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/publication/xie-2018-consistent/","section":"publication","summary":"Consistent subtyping is employed in some gradual type systems to validate type conversions. The original definition by Siek and Taha serves as a guideline for designing many gradual type systems with subtyping. Polymorphic types `a la System F also induce a subtyping relation that relates polymorphic types to their instantiations. However Siek and Taha’s definition is not adequate for polymorphic subtyping. The first goal of this paper is to propose a generalization of consistent subtyping that is adequate for polymorphic subtyping, and subsumes the original definition by Siek and Taha. The new definition of consistent subtyping provides novel insights with respect to previous polymorphic gradual type systems, which did not employ consistent subtyping. The second goal of this paper is to present a gradually typed calculus for implicit (higher-rank) polymorphism that uses our new notion of consistent subtyping. We develop both declarative and (bi-directional) algorithmic versions for the type system. We prove that the new calculus satisfies all static aspects of the refined criteria for gradual typing, which are mechanically formalized using the Coq proof assistant.","tags":["type-system","gradual-typing"],"title":"Consistent Subtyping for All","type":"publication"},{"authors":["Yanpeng Yang","(Jeremy) Xuan Bi","Bruno C. d. S. Oliveira"],"categories":null,"content":"","date":1472688000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1472688000,"objectID":"692d38b8e822ff52044be8f645c1918f","permalink":"https://bixuanzju.github.io/publication/yang-2016-unified/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/publication/yang-2016-unified/","section":"publication","summary":"Traditional designs for functional languages (such as Haskell or ML) have separate sorts of syntax for terms and types. In contrast, many dependently typed languages use a unified syntax that accounts for  both  terms  and  types.  Unified  syntax  has  some  interesting  advantages over  separate syntax,  including less  duplication  of concepts,  and added  expressiveness.  However,  integrating unrestricted general  recursion  in  calculi  with  unified  syntax  is  challenging  when  some  level  of type-level  computation  is  present,  as decidable type-checking is  easily lost. This paper argues that the advantages of unified syntax also apply to traditional functional languages, and there is no need to give up decidable type-checking. We present a dependently typed calculus that uses unified syntax, supports general recursion and has decidable type-checking. The key to retain decidable type-checking is a generalization of iso-recursive types called iso-types. Iso-types replace the conversion rule typically used in dependently typed calculus, and make every computation explicit via cast operators. We study two variants of the calculus that differ on the reduction  strategy  employed  by  the  cast  operators,  and  give  different trade-offs in terms of simplicity and expressiveness","tags":["type-system","dependent-type"],"title":"Unified Syntax with Iso-Types","type":"publication"},{"authors":["(Jeremy) Xuan Bi","吳恩達"],"categories":["Demo","教程"],"content":"Overview  The Wowchemy website builder for Hugo, along with its starter templates, is designed for professional creators, educators, and teams/organizations - although it can be used to create any kind of site The template can be modified and customised to suit your needs. It\u0026rsquo;s a good platform for anyone looking to take control of their data and online identity whilst having the convenience to start off with a no-code solution (write in Markdown and customize with YAML parameters) and having flexibility to later add even deeper personalization with HTML and CSS You can work with all your favourite tools and apps with hundreds of plugins and integrations to speed up your workflows, interact with your readers, and much more    The template is mobile first with a responsive design to ensure that your site looks stunning on every device.   Get Started  👉 Create a new site 📚 Personalize your site 💬 Chat with the Wowchemy community or Hugo community 🐦 Twitter: @wowchemy @GeorgeCushen #MadeWithWowchemy 💡 Request a feature or report a bug for Wowchemy ⬆️ Updating Wowchemy? View the Update Guide and Release Notes  Crowd-funded open-source software To help us develop this template and software sustainably under the MIT license, we ask all individuals and businesses that use it to help support its ongoing maintenance and development via sponsorship.\n❤️ Click here to become a sponsor and help support Wowchemy\u0026rsquo;s future ❤️ As a token of appreciation for sponsoring, you can unlock these awesome rewards and extra features 🦄✨\nEcosystem  Wowchemy Admin: An admin tool to automatically import publications from BibTeX  Inspiration Check out the latest demo of what you\u0026rsquo;ll get in less than 10 minutes, or view the showcase of personal, project, and business sites.\nFeatures  Page builder - Create anything with widgets and elements Edit any type of content - Blog posts, publications, talks, slides, projects, and more! Create content in Markdown, Jupyter, or RStudio Plugin System - Fully customizable color and font themes Display Code and Math - Code highlighting and LaTeX math supported Integrations - Google Analytics, Disqus commenting, Maps, Contact Forms, and more! Beautiful Site - Simple and refreshing one page design Industry-Leading SEO - Help get your website found on search engines and social media Media Galleries - Display your images and videos with captions in a customizable gallery Mobile Friendly - Look amazing on every screen with a mobile friendly version of your site Multi-language - 34+ language packs including English, 中文, and Português Multi-user - Each author gets their own profile page Privacy Pack - Assists with GDPR Stand Out - Bring your site to life with animation, parallax backgrounds, and scroll effects One-Click Deployment - No servers. No databases. Only files.  Themes Wowchemy and its templates come with automatic day (light) and night (dark) mode built-in. Alternatively, visitors can choose their preferred mode - click the moon icon in the top right of the Demo to see it in action! Day/night mode can also be disabled by the site admin in params.toml.\nChoose a stunning theme and font for your site. Themes are fully customizable.\nLicense Copyright 2016-present George Cushen.\nReleased under the MIT license.\n","date":1461110400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"279b9966ca9cf3121ce924dca452bb1c","permalink":"https://bixuanzju.github.io/post/getting-started/","publishdate":"2016-04-20T00:00:00Z","relpermalink":"/post/getting-started/","section":"post","summary":"Welcome 👋 We know that first impressions are important, so we've populated your new site with some initial content to help you get familiar with everything in no time.","tags":["Academic","开源"],"title":"Welcome to Wowchemy, the website builder for Hugo","type":"post"},{"authors":null,"categories":null,"content":"Research middleware compiler from System F-based languages to Java with the Imperative Functional Object encoding\n","date":1457222400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1457222400,"objectID":"c6a6429de2227f32030b80ef012bc307","permalink":"https://bixuanzju.github.io/project/fcore/","publishdate":"2016-03-06T00:00:00Z","relpermalink":"/project/fcore/","section":"project","summary":"Research middleware compiler from System F-based languages to Java with the Imperative Functional Object encoding","tags":["haskell","type-system"],"title":"FCore","type":"project"},{"authors":["Tomas Tauber","(Jeremy) Xuan Bi","Zhiyuan Shi","Weixin Zhang","Huang Li","Zhenrui Zhang","Bruno C. d. S. Oliveira"],"categories":null,"content":"","date":1441065600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1441065600,"objectID":"600a3412a442b75d7faae5419bd475a2","permalink":"https://bixuanzju.github.io/publication/tauber-2015-memory/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/publication/tauber-2015-memory/","section":"publication","summary":"This paper presents FCore: a JVM implementation of System F with support for full tail-call elimination (TCE). Our compilation technique for FCore is innovative in two respects: it uses a new representation for first-class functions called imperative functional objects; and it provides a way to do TCE on the JVM using constant space. Unlike conventional TCE techniques on the JVM, allocated function objects are reused in chains of tail calls. Thus, programs written in FCore can use idiomatic functional programming styles, relying on TCE, and perform well without worrying about the JVM limitations. Our empirical results show that programs which use tail calls can run in constant space and with low execution time overhead when compiled with FCore.","tags":["type-system"],"title":"Memory-efficient Tail Calls in the JVM with Imperative Functional Objects","type":"publication"},{"authors":["Xi Chen","Huajun Chen","(Jeremy) Xuan Bi","Peiqin Gu","Jiaoyan Chen","Zhaohui Wu"],"categories":null,"content":"","date":1388534400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1388534400,"objectID":"4b3cf86f2370515918dd40296b3426ce","permalink":"https://bixuanzju.github.io/publication/chen-2014-biotcm/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/publication/chen-2014-biotcm/","section":"publication","summary":"Understanding the functional mechanisms of the complex biological system as a whole is drawing more and more attention in global health care management. Traditional Chinese Medicine (TCM), essentially different from Western Medicine (WM), is gaining increasing attention due to its emphasis on individual wellness and natural herbal medicine, which satisfies the goal of integrative medicine. However, with the explosive growth of biomedical data on the Web, biomedical researchers are now confronted with the problem of large-scale data analysis and data query. Besides that, biomedical data also has a wide coverage which usually comes from multiple heterogeneous data sources and has different taxonomies, making it hard to integrate and query the big biomedical data. Embedded with domain knowledge from different disciplines all regarding human biological systems, the heterogeneous data repositories are implicitly connected by human expert knowledge. Traditional search engines cannot provide accurate and comprehensive search results for the semantically associated knowledge since they only support keywords-based searches. In this paper, we present BioTCM-SE, a semantic search engine for the information retrieval of modern biology and TCM, which provides biologists with a comprehensive and accurate associated knowledge query platform to greatly facilitate the implicit knowledge discovery between WM and TCM.","tags":[],"title":"BioTCM-SE: a semantic search engine for the information retrieval of modern biology and traditional Chinese medicine","type":"publication"}]