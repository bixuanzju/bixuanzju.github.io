[{"authors":["**Xuan Bi**","Ningning Xie","Bruno C. d. S. Oliveira","Tom Schrijvers"],"categories":null,"content":"","date":1548460800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1548460800,"objectID":"5144139a2e64726677447e2af73cedf3","permalink":"https://bixuanzju.github.io/publication/fii/","publishdate":"2019-01-26T00:00:00Z","relpermalink":"/publication/fii/","section":"publication","summary":"Popular programming techniques such as shallow embeddings of Domain Specific Languages (DSLs), finally tagless or object algebras are built on the principle of compositionality. However, existing programming languages only support simple compositional designs well, and have limited support for more sophisticated ones. This paper presents the F+i calculus, which supports highly modular and compositional designs that improve on existing techniques. These improvements are due to the combination of three features: disjoint intersection types with a merge operator; parametric (disjoint) polymorphism; and BCD-style distributive subtyping. The main technical challenge is F+i's proof of coherence. A naive adaptation of ideas used in System F's parametricity to canonicity (the logical relation used by F+i to prove coherence) results in an ill-founded logical relation. To solve the problem our canonicity relation employs a different technique based on immediate substitutions and a restriction to predicative instantiations. Besides coherence, we show several other important meta-theoretical results, such as type-safety, sound and complete algorithmic subtyping, and decidability of the type system. Remarkably, unlike F","tags":null,"title":"Distributive Disjoint Polymorphism for Compositional Programming","type":"publication"},{"authors":["Ningning Xie","**Xuan Bi**","Bruno C. d. S. Oliveira","Tom Schrijvers"],"categories":null,"content":"","date":1547596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1547596800,"objectID":"3686afc76eff333640b79df96b7b0d98","permalink":"https://bixuanzju.github.io/publication/consistent/","publishdate":"2019-01-16T00:00:00Z","relpermalink":"/publication/consistent/","section":"publication","summary":"Consistent subtyping is employed in some gradual type systems to validate type conversions. The original definition by Siek and Taha serves as a guideline for designing gradual type systems with subtyping. Polymorphic types à la System F also induce a subtyping relation that relates polymorphic types to their instantiations. However Siek and Taha's definition is not adequate for polymorphic subtyping. The first goal of this paper is to propose a generalization of consistent subtyping that is adequate for polymorphic subtyping, and subsumes the original definition by Siek and Taha. The new definition of consistent subtyping provides novel insights with respect to previous polymorphic gradual type systems, which did not employ consistent subtyping. The second goal of this paper is to present a gradually typed calculus for implicit (higher-rank) polymorphism that uses our new notion of consistent subtyping. We develop both declarative and (bidirectional) algorithmic versions for the type system. The algorithmic version employs techniques developed by Dunfield and Krishnaswami to deal with instantiation. We prove that the new calculus satisfies all static aspects of the refined criteria for gradual typing. We also study an extension of the type system with static and gradual type parameters, in an attempt to support a variant of the dynamic criterion for gradual typing. Armed with a coherence conjecture for the extended calculus, we show that the dynamic gradual guarantee of our source language can be reduced to that of λB, which, at the time of writing, is still an open question. Most of the metatheory of this paper, except some manual proofs for the algorithmic type system and extensions, has been mechanically formalized using the Coq proof assistant.","tags":null,"title":"Consistent Subtyping for All","type":"publication"},{"authors":["**Xuan Bi**"],"categories":null,"content":"","date":1544659200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1544659200,"objectID":"0f40cf545adf79432be77d9037b7794b","permalink":"https://bixuanzju.github.io/publication/thesis/","publishdate":"2018-12-13T00:00:00Z","relpermalink":"/publication/thesis/","section":"publication","summary":"Programs are hard to write. It was so 50 years ago at the time of the so-called software crisis; it still remains so nowadays. Over the years, we have learned---the hard way---that software should be constructed in a modular way, i.e., as a network of smaller and loosely connected modules. To facilitate writing modular code, researchers and software practitioners have developed new methodologies; new programming paradigms; stronger type systems; as well as better tooling support. Still, this is not enough to cope with today's needs. Several reasons have been raised for the lack of satisfactory solutions, but one that is constantly pointed out is the inadequacy of existing programming languages for the construction of modular software. This thesis investigates disjoint intersection types, a variant of intersection types. Disjoint intersections types have great potential to serve as a foundation for powerful, flexible and yet type-safe and easy to reason OO languages, suitable for writing modular software. On the theoretical side, this thesis shows how to significantly increase the expressiveness of disjoint intersection types by adding support for nested composition, along with parametric polymorphism. Nested composition extends inheritance to work on a whole family of classes, enabling high degrees of modularity and code reuse. The combination with parametric polymorphism further improves the state-of-art encodings of extensible designs. However, the extension with nested composition and parametric polymorphism is challenging, for two different reasons. Firstly, the subtyping relation that supports these features is non-trivial. Secondly, the syntactic method used to prove coherence for previous calculi with disjoint intersection types is too inflexible. This thesis addresses the first problem by adapting and extending the well-known BCD subtyping with records, universal quantification and coercions. To address the second problem, this thesis proposes a powerful proof method to establish coherence. Hence, this thesis puts disjoint intersection types on a solid footing by thoroughly exploring their meta-theoretical properties. On the pragmatic side, this thesis proposes a new language design with support for first-class traits, dynamic inheritance and nested composition. First-class traits allow two objects of statically unknown types to be composed without conflicts. Dynamic inheritance allows a class to inherit from other classes at run time. To address the challenges of typing first-class traits and detecting conflicts statically, this thesis shows how to model source language constructs for first-class traits and dynamic inheritance by leveraging the fine-grained expressiveness of disjoint intersection types. To illustrate the applicability of the new design, this thesis conducts a case study that modularizes programming language features using a highly modular form of visitor. All the results and metatheory presented (unless otherwise indicated) in this thesis are mechanized in Coq in order to show the rigorousness of the approach. This thesis unifies ideas that are seemingly unrelated but powerful on their own---dynamic inheritance, first-class traits, nested composition---by a lightweight mechanism, thus providing new insights into software modularity and extensibility.","tags":null,"title":"Disjoint Intersection Types: Theory and Practice","type":"publication"},{"authors":null,"categories":null,"content":"","date":1542448903,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1542448903,"objectID":"cdb1378949a74a4b1494a5dfe07bdfc8","permalink":"https://bixuanzju.github.io/project/fii/","publishdate":"2018-11-17T18:01:43+08:00","relpermalink":"/project/fii/","section":"project","summary":"Coq formalization and implementation of the Fi+ calculus","tags":[],"title":"Fi+","type":"project"},{"authors":["**Xuan Bi**","Bruno C. d. S. Oliveira","Tom Schrijvers"],"categories":null,"content":"","date":1532044800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1532044800,"objectID":"880b6a0dd945e9cab5f650066d2d7702","permalink":"https://bixuanzju.github.io/publication/nested-composition/","publishdate":"2018-07-20T00:00:00Z","relpermalink":"/publication/nested-composition/","section":"publication","summary":"Calculi with disjoint intersection types support an introduction form for intersections called the merge operator, while retaining a coherent semantics. Disjoint intersections types have great potential to serve as a foundation for powerful, flexible and yet type-safe and easy to reason OO languages. This paper shows how to significantly increase the expressive power of disjoint intersection types by adding support for nested subtyping and composition, which enables simple forms of family polymorphism to be expressed in the calculus. The extension with nested subtyping and composition is challenging, for two different reasons. Firstly, the subtyping relation that supports these features is non-trivial, especially when it comes to obtaining an algorithmic version. Secondly, the syntactic method used to prove coherence for previous calculi with disjoint intersection types is too inflexible, making it hard to extend those calculi with new features (such as nested subtyping). We show how to address the first problem by adapting and extending the Barendregt, Coppo and Dezani (BCD) subtyping rules for intersections with records and coercions. A sound and complete algorithmic system is obtained by using an approach inspired by Pierce’s work. To address the second problem we replace the syntactic method to prove coherence, by a semantic proof method based on logical relations. Our work has been fully formalized in Coq, and we have an implementation of our calculus.","tags":null,"title":"The Essence of Nested Composition","type":"publication"},{"authors":["**Xuan Bi**","Bruno C. d. S. Oliveira"],"categories":null,"content":"","date":1531958400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1531958400,"objectID":"0c2d1427b4dfc00fbd3ed70c116b1bb3","permalink":"https://bixuanzju.github.io/publication/typed-first-class-traits/","publishdate":"2018-07-19T00:00:00Z","relpermalink":"/publication/typed-first-class-traits/","section":"publication","summary":"Many dynamically typed languages (including JavaScript, Ruby, Python or Racket) support first-class classes, or related concepts such as first-class traits and/or mixins. In those languages classes are first-class values and, like any other values, they can be passed as an argument, or returned from a function. Furthermore first class classes support dynamic inheritance: i.e. they can inherit from other classes at runtime, enabling programmers to abstract over the inheritance hierarchy. In contrast, type system limitations prevent most statically typed languages from having first-class classes and dynamic inheritance. This paper shows the design of SEDEL: a polymorphic statically typed language with first- class traits, supporting dynamic inheritance as well as conventional OO features such as dynamic dispatching and abstract methods. The type system for SEDEL is based on the recent work on disjoint intersection types and disjoint polymorphism. However, such previous work is aimed at core calculi, and omits important features for practical OO languages, including (dynamic) inheritance, dynamic dispatching and abstract methods. This paper addresses that gap by showing how to model source language constructs for traits that support such missing features. Inspired by Cook’s work on the denotational semantics for inheritance, we show how to design a source language that can be elaborated into Alpuim et al.'s Fi which is a polymorphic calculus with records supporting disjoint polymorphism. We illustrate the applicability of SEDEL with several example uses for first-class traits, and a case study that modularizes programming language interpreters using a highly modular form of visitors.","tags":null,"title":"Typed First-Class Traits","type":"publication"},{"authors":null,"categories":null,"content":"","date":1523527303,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1523527303,"objectID":"9c2cb6668b879040302dff6f9bce9603","permalink":"https://bixuanzju.github.io/project/gpc/","publishdate":"2018-04-12T18:01:43+08:00","relpermalink":"/project/gpc/","section":"project","summary":"Haskell implementation of Gradually Polymorphic Calculus","tags":[],"title":"GPC","type":"project"},{"authors":null,"categories":null,"content":"","date":1523527303,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1523527303,"objectID":"d6d76f0f128e82795395e3fc270093e8","permalink":"https://bixuanzju.github.io/project/necolus/","publishdate":"2018-04-12T18:01:43+08:00","relpermalink":"/project/necolus/","section":"project","summary":"Coq formalization of a coherent calculus with records and disjoint intersection types that supports nested composition","tags":[],"title":"NeColus","type":"project"},{"authors":null,"categories":null,"content":"","date":1523527091,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1523527091,"objectID":"68f37dd1b2fa350348d70f887055ec39","permalink":"https://bixuanzju.github.io/project/sedel/","publishdate":"2018-04-12T17:58:11+08:00","relpermalink":"/project/sedel/","section":"project","summary":"Haskell implementation of a type system for first-class traits","tags":[],"title":"SEDEL","type":"project"},{"authors":["Ningning Xie","**Xuan Bi**","Bruno C. d. S. Oliveira"],"categories":null,"content":"","date":1520726400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1520726400,"objectID":"a94fb4887d50d2be336dd7c47ca7fe10","permalink":"https://bixuanzju.github.io/publication/consistent-subtyping/","publishdate":"2018-03-11T00:00:00Z","relpermalink":"/publication/consistent-subtyping/","section":"publication","summary":"Consistent subtyping is employed in some gradual type systems to validate type conversions. The original definition by Siek and Taha serves as a guideline for designing many gradual type systems with subtyping. Polymorphic types `a la System F also induce a subtyping relation that relates polymorphic types to their instantiations. However Siek and Taha’s definition is not adequate for polymorphic subtyping. The first goal of this paper is to propose a generalization of consistent subtyping that is adequate for polymorphic subtyping, and subsumes the original definition by Siek and Taha. The new definition of consistent subtyping provides novel insights with respect to previous polymorphic gradual type systems, which did not employ consistent subtyping. The second goal of this paper is to present a gradually typed calculus for implicit (higher-rank) polymorphism that uses our new notion of consistent subtyping. We develop both declarative and (bi-directional) algorithmic versions for the type system. We prove that the new calculus satisfies all static aspects of the refined criteria for gradual typing, which are mechanically formalized using the Coq proof assistant.","tags":null,"title":"Consistent Subtyping for All","type":"publication"},{"authors":null,"categories":null,"content":"","date":1491991303,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1491991303,"objectID":"a5b3ad60c0a1c1479528949e782894c9","permalink":"https://bixuanzju.github.io/project/category/","publishdate":"2017-04-12T18:01:43+08:00","relpermalink":"/project/category/","section":"project","summary":"Category theory formalized in Agda","tags":[],"title":"category-agda","type":"project"},{"authors":["Xuan Bi"],"categories":null,"content":"","date":1483200000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1483200000,"objectID":"f0aa94c7bcea7edbaa2eab6a64149e31","permalink":"https://bixuanzju.github.io/talk/consistent-subtyping/","publishdate":"2017-01-01T00:00:00+08:00","relpermalink":"/talk/consistent-subtyping/","section":"talk","summary":"Consistent subtyping is employed in some gradual type systems to validate type conversions. The original definition by Siek and Taha serves as a guideline for designing many gradual type systems with subtyping. Polymorphic types `a la System F also induce a subtyping relation that relates polymorphic types to their instantiations. However Siek and Taha’s definition is not adequate for polymorphic subtyping. The first goal of this paper is to propose a generalization of consistent subtyping that is adequate for polymorphic subtyping, and subsumes the original definition by Siek and Taha. The new definition of consistent subtyping provides novel insights with respect to previous polymorphic gradual type systems, which did not employ consistent subtyping. The second goal of this paper is to present a gradually typed calculus for implicit (higher-rank) polymorphism that uses our new notion of consistent subtyping. We develop both declarative and (bi-directional) algorithmic versions for the type system. We prove that the new calculus satisfies all static aspects of the refined criteria for gradual typing, which are mechanically formalized using the Coq proof assistant.","tags":null,"title":"Consistent Subtyping for All","type":"talk"},{"authors":["Xuan Bi"],"categories":null,"content":"","date":1483200000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1483200000,"objectID":"2c8809a33e7c86561bc6b507db5fd903","permalink":"https://bixuanzju.github.io/talk/nested/","publishdate":"2017-01-01T00:00:00+08:00","relpermalink":"/talk/nested/","section":"talk","summary":"Calculi with disjoint intersection types support an introduction form for intersections called the merge operator, while retaining a coherent semantics. Disjoint intersections types have great potential to serve as a foundation for powerful, flexible and yet type-safe and easy to reason OO languages. This paper shows how to significantly increase the expressive power of disjoint intersection types by adding support for nested subtyping and composition, which enables simple forms of family polymorphism to be expressed in the calculus. The extension with nested sub- typing and composition is challenging, for two different reasons. Firstly, the subtyping relation that supports these features is non-trivial, especially when it comes to obtaining an algorithmic version. Secondly, the syntactic method used to prove coherence for previous calculi with disjoint intersection types is too inflexible, making it hard to extend those calculi with new features (such as nested subtyping). We show how to address the first problem by adapting and extending the Barendregt, Coppo and Dezani (BCD) subtyping rules for intersections with records and coercions. A sound and complete algorithmic system is obtained by using an approach inspired by Pierce’s work. To address the second problem we replace the syntactic method to prove coherence, by a semantic proof method based on logical relations. Our work has been fully formalized in Coq, and we have an implementation of our calculus.","tags":[],"title":"The Essence of Nested Composition","type":"talk"},{"authors":["Xuan Bi"],"categories":null,"content":"","date":1483200000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1483200000,"objectID":"b8ce65b4267492e0240cfaaef14e2df3","permalink":"https://bixuanzju.github.io/talk/traits/","publishdate":"2017-01-01T00:00:00+08:00","relpermalink":"/talk/traits/","section":"talk","summary":"Many dynamically typed languages (including JavaScript, Ruby, Python or Racket) support first-class classes, or related concepts such as first-class traits and/or mixins. In those languages classes are first-class values and, like any other values, they can be passed as an argument, or returned from a function. Furthermore first class classes support dynamic inheritance: i.e. they can inherit from other classes at runtime, enabling programmers to abstract over the inheritance hierarchy. In contrast, type system limitations prevent most statically typed languages from having first-class classes and dynamic inheritance. This paper shows the design of SEDEL: a polymorphic statically typed language with first- class traits, supporting dynamic inheritance as well as conventional OO features such as dynamic dispatching and abstract methods. The type system for SEDEL is based on the recent work on disjoint intersection types and disjoint polymorphism. However, such previous work is aimed at core calculi, and omits important features for practical OO languages, including (dynamic) inheritance, dynamic dispatching and abstract methods. This paper addresses that gap by showing how to model source language constructs for traits that support such missing features. Inspired by Cook’s work on the denotational semantics for inheritance, we show how to design a source language that can be elaborated into Alpuim et al.'s Fi which is a polymorphic calculus with records supporting disjoint polymorphism. We illustrate the applicability of SEDEL with several example uses for first-class traits, and a case study that modularizes programming language interpreters using a highly modular form of visitors.","tags":null,"title":"Typed First-Class Traits","type":"talk"},{"authors":["Yanpeng Yang","**Xuan Bi**","Bruno C. d. S. Oliveira"],"categories":null,"content":"","date":1472688000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1472688000,"objectID":"fb8dfdcbbe2d46fb8fe680c3ca4a63e7","permalink":"https://bixuanzju.github.io/publication/unifed-syntax/","publishdate":"2016-09-01T00:00:00Z","relpermalink":"/publication/unifed-syntax/","section":"publication","summary":"Traditional designs for functional languages (such as Haskell or ML) have separate sorts of syntax for terms and types. In contrast, many dependently typed languages use a unified syntax that accounts for  both  terms  and  types.  Unified  syntax  has  some  interesting  advantages over  separate syntax,  including less  duplication  of concepts,  and added  expressiveness.  However,  integrating unrestricted general  recursion  in  calculi  with  unified  syntax  is  challenging  when  some  level  of type-level  computation  is  present,  as decidable type-checking is  easily lost. This paper argues that the advantages of unified syntax also apply to traditional functional languages, and there is no need to give up decidable type-checking. We present a dependently typed calculus that uses unified syntax, supports general recursion and has decidable type-checking. The key to retain decidable type-checking is a generalization of iso-recursive types called iso-types. Iso-types replace the conversion rule typically used in dependently typed calculus, and make every computation explicit via cast operators. We study two variants of the calculus that differ on the reduction  strategy  employed  by  the  cast  operators,  and  give  different trade-offs in terms of simplicity and expressiveness","tags":null,"title":"Unified Syntax with Iso-Types","type":"publication"},{"authors":null,"categories":null,"content":"","date":1460455303,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1460455303,"objectID":"c6a6429de2227f32030b80ef012bc307","permalink":"https://bixuanzju.github.io/project/fcore/","publishdate":"2016-04-12T18:01:43+08:00","relpermalink":"/project/fcore/","section":"project","summary":"Research middleware compiler from System F-based languages to Java with the Imperative Functional Object encoding","tags":[],"title":"FCore","type":"project"},{"authors":["Tomas Tauber","**Xuan Bi**","Zhiyuan Shi","Weixin Zhang","Huang Li","Zhenrui Zhang","Bruno C. d. S. Oliveira"],"categories":null,"content":"","date":1441065600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1441065600,"objectID":"680efa2136cf1abfc4344f5ee69111d1","permalink":"https://bixuanzju.github.io/publication/ifo/","publishdate":"2015-09-01T00:00:00Z","relpermalink":"/publication/ifo/","section":"publication","summary":"This paper presents FCore: a JVM implementation of System F with support for full tail-call elimination (TCE). Our compilation technique for FCore is innovative in two respects: it uses a new representation for first-class functions called imperative functional objects; and it provides a way to do TCE on the JVM using constant space. Unlike conventional TCE techniques on the JVM, allocated function objects are reused in chains of tail calls. Thus, programs written in FCore can use idiomatic functional programming styles, relying on TCE, and perform well without worrying about the JVM limitations. Our empirical results show that programs which use tail calls can run in constant space and with low execution time overhead when compiled with FCore.","tags":null,"title":"Memory-efficient Tail Calls in the JVM with Imperative Functional Objects","type":"publication"}]